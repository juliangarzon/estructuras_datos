# Data Structures Course

[![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)](https://www.oracle.com/java/)
[![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)](https://www.python.org/)
[![Node.js](https://img.shields.io/badge/Node.js-43853D?style=for-the-badge&logo=node.js&logoColor=white)](https://nodejs.org/)

## 📚 Course Overview

This repository contains all materials for the **Data Structures** course. The course follows a **depth-over-breadth** approach, focusing on mastering fundamental data structures through practical implementation.

**Each topic includes both theory and hands-on practice sessions.**

## 📖 Course Topics

### 🏗️ Fundamentals and Linear Structures

**Introduction to Data Structures**
- Abstract Data Types (ADTs)
- Difference between ADT and implementation
- Selection criteria for data structures
- Basic Java setup and environment

**Arrays**
- Static arrays in Java
- Memory layout and direct access
- Basic operations: insert, search, delete
- Array manipulation and traversal
- Multidimensional arrays

**Dynamic Arrays (ArrayList)**
- Limitations of static arrays
- Growing arrays automatically
- Capacity vs size concept
- Resizing strategies
- ArrayList implementation from scratch

**Linked Lists**
- Singly linked lists
- Doubly linked lists
- Circular linked lists
- Node concept and references in Java
- Basic operations: add, remove, find
- Memory management with references
- When to use each type
- Implementation of complex operations

### ⚙️ Specialized Structures

**Stacks**
- Last In, First Out (LIFO) principle
- Implementation with arrays
- Implementation with linked lists
- Applications: undo/redo, parsing, compilers
- Expression evaluation

**Queues**
- First In, First Out (FIFO) principle
- Circular array implementation
- Linked list implementation
- Priority queues (basic concept)
- Queue applications and simulations

**Recursion**
- Recursive thinking and design
- Base cases and recursive cases
- Call stack mechanics
- Recursion vs iteration trade-offs
- Common recursive problems

**Backtracking**
- Backtracking algorithm pattern
- N-Queens problem
- Maze solving algorithms
- Sudoku solver
- Combination and permutation generation

### 🌳 Trees and Performance Analysis

**Binary Trees**
- Tree terminology: root, leaves, height, level
- Binary tree properties
- Tree traversals: preorder, inorder, postorder
- Recursive tree operations
- Tree height and node counting

**Binary Search Trees (BST)**
- BST properties and invariants
- Search, insert, and delete operations
- Node deletion: three cases
- Finding successor and predecessor
- BST validation
- Tree statistics and analysis
- Comparison with linear structures

**Advanced Tree Concepts**
- Tree balancing concepts
- Degenerate cases analysis
- Introduction to self-balancing trees (conceptual)

**Performance Analysis**
- Big O notation and complexity analysis
- Time complexity of all implemented structures
- Space complexity considerations
- Practical performance comparison
- When to use each data structure
- Best practices in structure selection

## 🛠️ Technical Requirements

### Development Environment
- **Java JDK 11+** (primary language)
- **IDE:** IntelliJ IDEA, Eclipse, or VS Code
- **Git** for version control

### Alternative Languages
- **Python 3.8+** (student adaptation)
- **Node.js 16+** (student adaptation)

## 📁 Repository Structure

```
data-structures-course/
├── README.md
├── introduction/
├── arrays/
├── dynamic-arrays/
├── linked-lists/
├── stacks/
├── queues/
├── recursion/
├── backtracking/
├── binary-trees/
├── binary-search-trees/
├── performance-analysis/
└── examples/
    ├── java/
    ├── python/
    └── nodejs/
```

## 🎯 Learning Objectives

By the end of this course, students will be able to:

- Implement fundamental data structures from scratch
- Analyze time and space complexity
- Choose appropriate structures for specific problems
- Design efficient algorithms using various data structures
- Understand trade-offs between different implementations
- Apply recursive thinking to solve complex problems